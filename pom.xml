<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!--This element indicates what version of the object model this POM is using-->
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.wcx</groupId>
    <!--artifactId This element indicates the unique base name of the primary artifact being generated by this project.
    The primary artifact for a project is typically a JAR file. Secondary artifacts like source bundles also use the
    artifactId as part of their final name. A typical artifact produced by Maven would have the form
    <artifactId>-<version>.<extension> (for example, myapp-1.0.jar).-->
    <artifactId>maven-start</artifactId>
    <packaging>pom</packaging>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>app</module>
    </modules>
    <!-- This element indicates the package type to be used by this artifact (e.g. JAR, WAR, EAR, etc.)
     The default value for the packaging element is JAR so you do not have to specify this for most projects.-->
    <!-- packaging>jar</packaging -->

    <!--This element indicates the display name used for the project. This is often used in Maven's generated documentation.-->
    <name>wcx maven start</name>
    <!--This element indicates where the project's site can be found. This is often used in Maven's generated documentation.-->
    <url>http://www.haha.com</url>
    <!--This element provides a basic description of your project. This is often used in Maven's generated documentation.-->
    <description>this is a description</description>
    <!--可以在pom.xml或者 setting.xml中定义属性，${foo}访问属性-->
    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
        <foo>bar</foo>
    </properties>

    <!--统一维护版本号，避免子项目依赖同一个库，不同的版本号 top-level pom-->
    <!--Using the dependencyManagement element in a pom.xml allows
    you to reference a dependency in a child project without having to explicitly list the version. Maven will
    walk up the parent-child hierarchy until it finds a project with a dependencyManagement element, it
    will then use the version specified in this dependencyManagement elemen-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.2</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <!--父pom的依赖，子工程继承-->
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <!--greater than or equal to 3.8 but less than 4.0,[,](,)表示范围，[包括等于,(不包括等于-->
            <version>[3.8,4.0)</version>
            <!--<version>4.12</version>-->
            <!-- any version of JUnit no higher than 3.8.1-->
            <!--<version>[,3.8.1]</version>-->
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>swarmcache</groupId>
            <artifactId>swarmcache</artifactId>
            <version>1.0RC2</version>
            <!--you want to avoid adding a dependency on both caching
            libraries to any project that depends on your library
            In other words, you need both libraries to compile this library project, but you don’t want both libraries
            to show up as transitive runtime dependencies for the project that uses your library-->
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate</artifactId>
            <version>3.2.5.ga</version>
            <!--exclude a transitive dependency-->
            <!--The groupId or artifactId of the artifact has changed, where the current project requires an
            alternately named version from a dependency’s version - resulting in 2 copies of the same project in
            the classpath. Normally Maven would capture this conflict and use a single version of the project,
            but when groupId or artifactId are different, Maven will consider this to be two different
            libraries.-->
            <exclusions>
                <exclusion>
                    <groupId>javax.transaction</groupId>
                    <artifactId>jta</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--replace the transitive dependency with another dependency that provides the same functionality-->
        <dependency>
            <groupId>org.apache.geronimo.specs</groupId>
            <artifactId>geronimo-jta_1.1_spec</artifactId>
            <version>1.1</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.3</version>
                <!--The configuration element applies the given parameters to every goal from the compiler plugin-->
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <!--deploy jar to remote server,mycompany-repository定义在setting.xml文件中-->
    <distributionManagement>
        <repository>
            <id>mycompany-repository</id>
            <name>MyCompany Repository</name>
            <url>scp://repository.mycompany.com/repository/maven2</url>
        </repository>
    </distributionManagement>

</project>